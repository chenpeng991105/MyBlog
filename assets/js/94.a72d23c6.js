(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{575:function(e,a,t){"use strict";t.r(a);var p=t(4),n=Object(p.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"_1-webpack-打包原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-webpack-打包原理"}},[e._v("#")]),e._v(" 1.webpack 打包原理")]),e._v(" "),t("p",[e._v("webpack 打包原理是根据文件间的依赖关系对其进行静态分析，然后将这些模块按指定规则生成静态资源，当 webpack 构建程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle")]),e._v(" "),t("p",[e._v("webpack 只是一个打包模块的机制，只是把依赖的模块转化成可以代表这些包的静态文件。并不是什么 commonjs或者 amd 之类的模块化规范。webpack 就是识别你的 入口文件。识别你的模块依赖，来打包你的代码。")]),e._v(" "),t("p",[e._v("至于你的代码使用的是 commonjs 还是 amd 或者 es6 的 import。webpack 都会对其进行分析。来获取代码的依赖。")]),e._v(" "),t("p",[e._v("webpack 做的就是分析代码。转换代码，编译代码，输出代码。webpack 本身是一个node的模块，所以webpack.config.js 是以 commonjs 形式书写的(node中的模块化是commonjs规范的)")]),e._v(" "),t("p",[e._v("webpack 中每个模块有一个唯一的 id，是从0开始递增的。整个打包后的 bundle.js 是一个匿名自执行函数。参数则为一个数组。数组的每一项都是一个 function。function 的内容则为每个模块的内容，并按照 require 的顺序排列")]),e._v(" "),t("h2",{attrs:{id:"_2-webpack-执行流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-webpack-执行流程"}},[e._v("#")]),e._v(" 2.webpack 执行流程")]),e._v(" "),t("p",[e._v("webpack 的运行流程是一个串行的过程,从启动到结束会依次执行以下流程 :")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("初始化参数：从配置文件和 Shell 语句中读取与合并参数,得出最终的参数。")])]),e._v(" "),t("li",[t("p",[e._v("开始编译：用上一步得到的参数初始化 Compiler 对象,加载所有配置的插件,执行对象的 run 方法开始执行编译。")])]),e._v(" "),t("li",[t("p",[e._v("确定入口：根据配置中的 entry 找出所有的入口文件。")])]),e._v(" "),t("li",[t("p",[e._v("编译模块：从入口文件出发,调用所有配置的 Loader 对模块进行翻译,再找出该模块依赖的模块,再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。")])]),e._v(" "),t("li",[t("p",[e._v("完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后,得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。")])]),e._v(" "),t("li",[t("p",[e._v("输出资源：根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件加入到输出列表,这步是可以修改输出内容的最后机会。")])]),e._v(" "),t("li",[t("p",[e._v("输出完成：在确定好输出内容后,根据配置确定输出的路径和文件名,把文件内容写入到文件系统。")])])]),e._v(" "),t("p",[e._v("在以上过程中,webpack 会在特定的时间点广播出特定的事件,插件在监听到感兴趣的事件后会执行特定的逻辑,并且插件可以调用 webpack 提供的 API 改变 webpack 的运行结果")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://segmentfault.com/a/1190000021494964?utm_source=tag-newest#comment-area",target:"_blank",rel:"noopener noreferrer"}},[e._v("webpack打包原理 ? 看完这篇你就懂了 !"),t("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=n.exports}}]);