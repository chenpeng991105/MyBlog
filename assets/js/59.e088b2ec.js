(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{540:function(t,o,_){"use strict";_.r(o);var r=_(4),e=Object(r.a)({},(function(){var t=this,o=t.$createElement,_=t._self._c||o;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"_1-原型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-原型"}},[t._v("#")]),t._v(" 1.原型")]),t._v(" "),_("p",[t._v("在 JavaScript 中，每一个函数都有一个 prototype 对象属性，指向另一个对象（原型对象），prototype 的所有属性和方法都会被构造函数的实例所继承。所以，我们可以把那些公共不变的方法，直接定义在 prototype 对象属性上 （一般情况下，公共属性定义在构造函数里，公共方法定义在原型对象上）")]),t._v(" "),_("h2",{attrs:{id:"_2-原型链"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-原型链"}},[t._v("#")]),t._v(" 2.原型链")]),t._v(" "),_("p",[t._v("JavaScript 成员查找机制是按照原型链来查找的（就近原则）")]),t._v(" "),_("ol",[_("li",[t._v("当访问一个对象的属性（或方法）时，首先查找这个对象是否拥有该属性（或方法）")]),t._v(" "),_("li",[t._v("如果没有，就找它的原型（"),_("code",[t._v("__proto__")]),t._v("）指向的构造函数的原型对象（prototype）")]),t._v(" "),_("li",[t._v("如果还没有，就找原型对象的原型指向的 Object 的原型对象")]),t._v(" "),_("li",[t._v("以此类推，递归访问 "),_("code",[t._v("__proto__")]),t._v("，直到找到为止，找不到则为 null")])]),t._v(" "),_("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://blogimg2020.oss-cn-shenzhen.aliyuncs.com/blogimg/1490251-3089c135df71c956.webp"}}),t._v(" "),_("h2",{attrs:{id:"_3-prototype-与-proto-的关系与区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-prototype-与-proto-的关系与区别"}},[t._v("#")]),t._v(" 3."),_("code",[t._v("prototype")]),t._v(" 与 "),_("code",[t._v("__proto__")]),t._v(" 的关系与区别")]),t._v(" "),_("p",[_("strong",[_("code",[t._v("prototype")])]),t._v("（显式原型属性）：只有函数对象才具有 prototype 属性，这个属性指向一个对象，这个对象包含所有实例共享的属性和方法，这个对象也有一个 constructor 属性，指回原构造函数")]),t._v(" "),_("p",[_("strong",[_("code",[t._v("__proto__")])]),t._v("（隐式原型属性）：所有对象都具有该属性，指向构造该对象的构造函数的原型")])])}),[],!1,null,null,null);o.default=e.exports}}]);