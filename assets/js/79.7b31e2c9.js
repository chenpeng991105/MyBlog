(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{560:function(t,e,s){"use strict";s.r(e);var v=s(4),a=Object(v.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"计算属性-computed"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#计算属性-computed"}},[t._v("#")]),t._v(" 计算属性 computed")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("computed 是惰性的，只有当真正用到的时候才会执行 get 中的方法，"),s("strong",[t._v("支持缓存")]),t._v("，只在相关响应式依赖发生改变时，才会重新进行计算，例如：")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("computed"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sum")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("count "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("ol",[s("li",[t._v("在 "),s("code",[t._v("sum")]),t._v(" 第一次进行求值的时候会读取响应式属性 "),s("code",[t._v("count")]),t._v("，收集到这个响应式数据作为依赖。并且计算出一个值来保存在自身的 "),s("code",[t._v("value")]),t._v(" 上，把 "),s("code",[t._v("dirty")]),t._v(" 设为 "),s("code",[t._v("false")]),t._v("，接下来在模板里再访问sum就直接返回这个求好的值 "),s("code",[t._v("value")]),t._v("，并不进行重新求值。")]),t._v(" "),s("li",[t._v("而 "),s("code",[t._v("count")]),t._v(" 发生变化了以后会通知 "),s("code",[t._v("sum")]),t._v(" 所对应的 "),s("code",[t._v("watcher")]),t._v(" 把自身的 "),s("code",[t._v("dirty")]),t._v(" 属性设置成 "),s("code",[t._v("true")]),t._v("，这也就相当于把重新求值的开关打开来了。这个很好理解，只有 "),s("code",[t._v("count")]),t._v(" 变化了， "),s("code",[t._v("sum")]),t._v(" 才需要重新去求值。")]),t._v(" "),s("li",[t._v("那么下次模板中再访问到 "),s("code",[t._v("this.sum")]),t._v(" 的时候，才会真正的去重新调用 "),s("code",[t._v("sum")]),t._v(" 函数求值，并且再次把 "),s("code",[t._v("dirty")]),t._v(" 设置为 "),s("code",[t._v("false")]),t._v("，等待下次的开启")])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("不支持异步")]),t._v("，当 computed 内有异步操作时无效，无法监听数据的变化")])]),t._v(" "),s("li",[s("p",[t._v("如果一个属性由其他属性计算而来，这个属性依赖其他属性，是多对一或者一对一，一般用 computed")])]),t._v(" "),s("li",[s("p",[t._v("如果 computed 属性属性值是函数，那么默认会走 get 方法，函数的返回值就是属性的属性值；在 computed 中，属性都有一个 get 和一个 set 方法，当数据变化时，调用 set 方法")])])]),t._v(" "),s("p",[s("a",{attrs:{href:"https://juejin.cn/post/6844904120290131982",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue 的计算属性真的会缓存吗？（保姆级教学，原理深入揭秘）"),s("OutboundLink")],1)]),t._v(" "),s("h2",{attrs:{id:"侦听器-watch"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#侦听器-watch"}},[t._v("#")]),t._v(" 侦听器 watch")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("不支持缓存")]),t._v("，数据变化，直接触发相应的操作")]),t._v(" "),s("li",[s("strong",[t._v("watch 支持异步")])]),t._v(" "),s("li",[t._v("监听的函数接收两个参数，第一个参数是最新的值，第二个参数是原本的值")]),t._v(" "),s("li",[t._v("当一个属性发生变化时，需要执行相应的操作，是一对多")]),t._v(" "),s("li",[t._v("监听数据必须是 data 中声明过或者父组件传递过来的 props 中的数据，当数据变化时，触发其他操作，watch 有两个属性：\n"),s("ol",[s("li",[s("strong",[t._v("immediate")]),t._v("："),s("strong",[t._v("组件加载立即触发回调函数执行")])]),t._v(" "),s("li",[s("strong",[t._v("deep")]),t._v("："),s("strong",[t._v("深度监听")]),t._v("，为了发现对象内部值的变化，可以在选项参数中指定 "),s("code",[t._v("deep: true")]),t._v("。注意监听数组的变更不需要这么做（当设置 "),s("code",[t._v("deep: true")]),t._v(" 时，会监听对象的所有属性，如果只需要监听对象的某一个属性，则可以使用字符串的形式监听）")])])])])])}),[],!1,null,null,null);e.default=a.exports}}]);