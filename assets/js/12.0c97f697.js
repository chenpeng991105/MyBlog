(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{493:function(_,v,t){"use strict";t.r(v);var e=t(4),o=Object(e.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"_1-回流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-回流"}},[_._v("#")]),_._v(" 1.回流")]),_._v(" "),t("p",[_._v("当对 DOM 的修改引发 DOM 几何尺寸变化的时候，会发生回流，每个页面至少有一次回流（页面第一次加载的时候）")]),_._v(" "),t("p",[_._v("以下操作会触发回流：")]),_._v(" "),t("ol",[t("li",[_._v("DOM 元素的几何属性发生变化，例如 "),t("code",[_._v("width")]),_._v("、"),t("code",[_._v("height")]),_._v("、"),t("code",[_._v("margin")]),_._v("、"),t("code",[_._v("padding")]),_._v("、"),t("code",[_._v("border")]),_._v("、"),t("code",[_._v("top")]),_._v("、"),t("code",[_._v("bottom")]),_._v("、"),t("code",[_._v("left")]),_._v("、"),t("code",[_._v("right")]),_._v(" 等")]),_._v(" "),t("li",[_._v("使 DOM 节点发生增减或者移动")]),_._v(" "),t("li",[_._v("读写 "),t("code",[_._v("offset")]),_._v(" 族、"),t("code",[_._v("scroll")]),_._v(" 族和 "),t("code",[_._v("client")]),_._v(" 族属性的时候，浏览器为了获取这些值，会进行回流操作")]),_._v(" "),t("li",[_._v("调用 "),t("code",[_._v("window.getComputedStyle")]),_._v(" 方法")])]),_._v(" "),t("p",[t("strong",[_._v("回流过程")])]),_._v(" "),t("p",[_._v("如果 DOM 结构发生变化，需要重新生成 DOM 树")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://sanyuan0704.top/my_blog/week11/2.jpg",alt:"2.jpg (689×241) (sanyuan0704.top)"}})]),_._v(" "),t("h2",{attrs:{id:"_2-重绘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-重绘"}},[_._v("#")]),_._v(" 2.重绘")]),_._v(" "),t("p",[_._v("当对 DOM 的修改导致样式发生变化，没有影响几何属性的时候，会发生重绘")]),_._v(" "),t("p",[t("strong",[_._v("重绘过程")])]),_._v(" "),t("p",[_._v("由于没有导致几何属性的变化，因此不需要重新布局")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://sanyuan0704.top/my_blog/week11/3.jpg",alt:"3.jpg (669×120) (sanyuan0704.top)"}})]),_._v(" "),t("p",[_._v("因此，重绘不会导致回流，而回流一定会导致重绘")]),_._v(" "),t("h2",{attrs:{id:"_3-合成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-合成"}},[_._v("#")]),_._v(" 3.合成")]),_._v(" "),t("p",[_._v("利用 CSS3 的"),t("code",[_._v("transform")]),_._v("、"),t("code",[_._v("opacity")]),_._v("、"),t("code",[_._v("filter")]),_._v("这些属性就可以实现合成的效果，也就是"),t("strong",[_._v("GPU加速")])]),_._v(" "),t("h3",{attrs:{id:"gpu加速的原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gpu加速的原因"}},[_._v("#")]),_._v(" GPU加速的原因")]),_._v(" "),t("p",[_._v("在合成的情况下，会直接跳过布局和绘制流程，直接进入"),t("code",[_._v("非主线程")]),_._v("处理的部分，即直接交给"),t("code",[_._v("合成线程")]),_._v("处理。交给它处理有两大好处:")]),_._v(" "),t("ol",[t("li",[_._v("能够充分发挥"),t("code",[_._v("GPU")]),_._v("的优势。合成线程生成位图的过程中会调用线程池，并在其中使用"),t("code",[_._v("GPU")]),_._v("进行加速生成，而GPU 是擅长处理位图数据的。")]),_._v(" "),t("li",[_._v("没有占用主线程的资源，即使主线程卡住了，效果依然能够流畅地展示。")])]),_._v(" "),t("h2",{attrs:{id:"_4-如何减少回流和重绘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-如何减少回流和重绘"}},[_._v("#")]),_._v(" 4.如何减少回流和重绘")]),_._v(" "),t("ol",[t("li",[_._v("避免频繁使用 style，而是采用修改 class 的方式")]),_._v(" "),t("li",[_._v("使用 createDocumentFragment 进行批量的 DOM 操作")]),_._v(" "),t("li",[_._v("对于 resize、scroll 等进行防抖/节流处理")]),_._v(" "),t("li",[_._v("使用"),t("code",[_._v("visibility")]),_._v("替换"),t("code",[_._v("display: none")]),_._v("，因为前者只会引起重绘，后者会引发回流")]),_._v(" "),t("li",[_._v("避免触发同步布局事件，我们在获取"),t("code",[_._v("offsetWidth")]),_._v("这类属性的值时，可以使用变量将查询结果存起来，避免多次查询，每次对"),t("code",[_._v("offset/scroll/client")]),_._v("等属性进行查询时都会触发回流")]),_._v(" "),t("li",[_._v("对于复杂动画效果,使用绝对定位让其脱离文档流，复杂的动画效果会频繁地触发回流重绘，我们可以将动画元素设置绝对定位从而脱离文档流避免反复回流重绘")]),_._v(" "),t("li",[_._v("添加 "),t("code",[_._v("will-change:transform")]),_._v("，让渲染引擎为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率。当然这个变化不限于 "),t("code",[_._v("tranform")]),_._v(" , 任何可以实现合成效果的 CSS 属性都能用 "),t("code",[_._v("will-change")]),_._v(" 来声明")])])])}),[],!1,null,null,null);v.default=o.exports}}]);